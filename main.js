/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  enabled: false,
  maskMode: "hide",
  revealMode: "word",
  excludeHeaders: true,
  revealSelection: true,
  showNotices: true
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Privacy Mode" });
    new import_obsidian.Setting(containerEl).setName("Privacy mode (global)").setDesc(
      "Turns masking on/off. You can also bind a hotkey to the Toggle privacy mode command."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
        this.plugin.settings.enabled = value;
        await this.plugin.saveSettings();
        this.plugin.notifySettingsChanged();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Mask style").setDesc("Hide characters entirely, or show ***** in place of letters.").addDropdown((dd) => {
      dd.addOption("hide", "Hiden (blank)");
      dd.addOption("blur", "Blurred");
      dd.addOption("password", "Password (*****) (may have formatting issues)");
      dd.setValue(this.plugin.settings.maskMode);
      dd.onChange(async (value) => {
        this.plugin.settings.maskMode = value;
        await this.plugin.saveSettings();
        this.plugin.notifySettingsChanged();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Reveal at cursor").setDesc("What should remain visible at the cursor position.").addDropdown((dd) => {
      dd.addOption("word", "Current word");
      dd.addOption("letter", "Current letter");
      dd.setValue(this.plugin.settings.revealMode);
      dd.onChange(async (value) => {
        this.plugin.settings.revealMode = value;
        await this.plugin.saveSettings();
        this.plugin.notifySettingsChanged();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Exclude headers").setDesc("Keep Markdown headers (#, ##, ###, etc.) visible.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.excludeHeaders).onChange(async (value) => {
        this.plugin.settings.excludeHeaders = value;
        await this.plugin.saveSettings();
        this.plugin.notifySettingsChanged();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Reveal selected text").setDesc("If enabled, selected text becomes visible while selected.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.revealSelection).onChange(async (value) => {
        this.plugin.settings.revealSelection = value;
        await this.plugin.saveSettings();
        this.plugin.notifySettingsChanged();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show notices").setDesc("Show a popup notice when toggling (useful while developing).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNotices).onChange(async (value) => {
        this.plugin.settings.showNotices = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Hotkey" });
    containerEl.createEl("p", {
      text: "Bind a hotkey to: Settings \u2192 Hotkeys \u2192 search \u201CToggle privacy mode\u201D. Obsidian keybinds commands rather than plugins hardcoding key combos."
    });
  }
};

// src/privacy/PrivacyController.ts
var import_obsidian2 = require("obsidian");
var import_state = require("@codemirror/state");

// src/privacy/cm6/PrivacyExtension.ts
var import_view2 = require("@codemirror/view");

// src/privacy/cm6/masking/buildMaskDecorations.ts
var import_view = require("@codemirror/view");

// src/privacy/cm6/masking/ranges.ts
function mergeRanges(ranges) {
  const sorted = ranges.filter((r) => r.to > r.from).slice().sort((a, b) => a.from - b.from || a.to - b.to);
  const merged = [];
  for (const r of sorted) {
    const last = merged[merged.length - 1];
    if (!last || r.from > last.to) merged.push({ ...r });
    else last.to = Math.max(last.to, r.to);
  }
  return merged;
}
function subtractRanges(base, subtract) {
  const b = mergeRanges(base);
  const s = mergeRanges(subtract);
  const out = [];
  for (const br of b) {
    let cursor = br.from;
    for (const sr of s) {
      if (sr.to <= cursor) continue;
      if (sr.from >= br.to) break;
      const start = Math.max(cursor, br.from);
      const end = Math.min(sr.from, br.to);
      if (end > start) out.push({ from: start, to: end });
      cursor = Math.max(cursor, sr.to);
      if (cursor >= br.to) break;
    }
    if (cursor < br.to) out.push({ from: cursor, to: br.to });
  }
  return out;
}
function computeRevealRanges(state, revealMode) {
  const pos = state.selection.main.head;
  if (revealMode === "letter") {
    if (pos < state.doc.length) return [{ from: pos, to: pos + 1 }];
    if (pos > 0) return [{ from: pos - 1, to: pos }];
    return [];
  }
  const line = state.doc.lineAt(pos);
  const idx = pos - line.from;
  const isWordChar = (ch) => /[A-Za-z0-9_]/.test(ch);
  let left = idx;
  while (left > 0 && isWordChar(line.text.charAt(left - 1))) left--;
  let right = idx;
  while (right < line.text.length && isWordChar(line.text.charAt(right))) right++;
  if (right <= left) {
    return [];
  }
  return [{ from: line.from + left, to: line.from + right }];
}

// src/privacy/cm6/masking/headers.ts
function isHeaderLine(lineText) {
  return /^\s{0,3}#{1,6}\s/.test(lineText);
}

// src/privacy/cm6/masking/buildMaskDecorations.ts
function buildMaskDecorations(view, enabled, settings) {
  if (!enabled) return import_view.Decoration.none;
  const builder = new class {
    constructor() {
      this.decos = [];
    }
    add(from, to, deco) {
      this.decos.push({ from, to, deco });
    }
    finish() {
      return import_view.Decoration.set(this.decos.map((d) => d.deco.range(d.from, d.to)), true);
    }
  }();
  const state = view.state;
  const cursorReveal = computeRevealRanges(state, settings.revealMode);
  const selectionReveal = settings.revealSelection ? state.selection.ranges.filter((r) => !r.empty).map((r) => ({ from: Math.min(r.from, r.to), to: Math.max(r.from, r.to) })) : [];
  const revealRanges = mergeRanges([...cursorReveal, ...selectionReveal]);
  for (const vr of view.visibleRanges) {
    let pos = vr.from;
    while (pos <= vr.to) {
      const line = state.doc.lineAt(pos);
      if (line.from > vr.to) break;
      const excludeThisLine = settings.excludeHeaders && isHeaderLine(line.text);
      if (!excludeThisLine) {
        const lineRange = { from: line.from, to: line.to };
        const revealInLine = revealRanges.filter((r) => r.to > lineRange.from && r.from < lineRange.to).map((r) => ({
          from: Math.max(r.from, lineRange.from),
          to: Math.min(r.to, lineRange.to)
        }));
        const maskSegments = subtractRanges([lineRange], revealInLine);
        for (const seg of maskSegments) {
          if (seg.to <= seg.from) continue;
          const length = seg.to - seg.from;
          const cls = settings.maskMode === "hide" ? "privacy-mask-hide" : settings.maskMode === "password" ? "privacy-mask-password" : "privacy-mask-blur";
          builder.add(seg.from, seg.to, import_view.Decoration.mark({ class: cls }));
        }
      }
      pos = line.to + 1;
      if (pos === line.from) break;
    }
  }
  return builder.finish();
}

// src/privacy/cm6/PrivacyExtension.ts
function buildPrivacyExtension(args) {
  const { enabled, settings } = args;
  const editorAttrs = import_view2.EditorView.editorAttributes.of({
    class: enabled ? "privacy-mode-enabled" : ""
  });
  const plugin = import_view2.ViewPlugin.fromClass(
    class PrivacyMaskPlugin {
      constructor(view) {
        this.decorations = buildMaskDecorations(view, enabled, settings);
      }
      update(update) {
        if (!enabled) {
          this.decorations = import_view2.Decoration.none;
          return;
        }
        if (update.docChanged || update.selectionSet || update.viewportChanged) {
          this.decorations = buildMaskDecorations(update.view, enabled, settings);
        }
      }
    },
    { decorations: (v) => v.decorations }
  );
  return [editorAttrs, plugin];
}

// src/privacy/PrivacyController.ts
var PrivacyController = class {
  constructor(plugin) {
    this.compartment = new import_state.Compartment();
    this.plugin = plugin;
    this.enabled = plugin.settings.enabled;
    this.baseExtension = this.compartment.of(
      buildPrivacyExtension({
        enabled: this.enabled,
        settings: this.plugin.settings
      })
    );
    this.plugin.registerEditorExtension(this.baseExtension);
    const off1 = this.plugin.app.workspace.on("active-leaf-change", () => this.apply("settings-change"));
    const off2 = this.plugin.app.workspace.on("layout-change", () => this.apply("settings-change"));
    this.plugin.register(() => this.plugin.app.workspace.offref(off1));
    this.plugin.register(() => this.plugin.app.workspace.offref(off2));
  }
  dispose() {
  }
  syncFromSettings(opts) {
    this.enabled = this.plugin.settings.enabled;
    this.apply(opts.reason);
  }
  toggleEnabled() {
    this.setEnabled(!this.enabled);
  }
  setEnabled(next) {
    if (this.enabled === next) return;
    this.enabled = next;
    this.plugin.settings.enabled = next;
    void this.plugin.saveSettings();
    this.plugin.notify(`Privacy mode: ${next ? "ON" : "OFF"}`);
    this.apply("command");
  }
  onSettingsChanged() {
    this.apply("settings-change");
  }
  apply(_reason) {
    const ext = buildPrivacyExtension({
      enabled: this.enabled,
      settings: this.plugin.settings
    });
    const effect = this.compartment.reconfigure(ext);
    for (const view of this.getAllMarkdownEditorViews()) {
      const cm = this.getEditorView(view);
      if (!cm) continue;
      cm.dispatch({ effects: effect });
    }
  }
  *getAllMarkdownEditorViews() {
    const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof import_obsidian2.MarkdownView) yield view;
    }
  }
  /**
   * Obsidian's Editor is wrapped; in CM6 it usually exposes `.cm` as EditorView.
   * This is the common plugin pattern.
   */
  getEditorView(view) {
    const editorAny = view.editor;
    const cm = editorAny == null ? void 0 : editorAny.cm;
    return cm != null ? cm : null;
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.privacy = new PrivacyController(this);
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.registerCommands();
    this.privacy.syncFromSettings({ reason: "startup" });
  }
  onunload() {
    var _a;
    (_a = this.privacy) == null ? void 0 : _a.dispose();
  }
  registerCommands() {
    this.addCommand({
      id: "toggle-privacy-mode",
      name: "Toggle privacy mode",
      callback: () => this.privacy.toggleEnabled()
    });
    this.addCommand({
      id: "enable-privacy-mode",
      name: "Enable privacy mode",
      callback: () => this.privacy.setEnabled(true)
    });
    this.addCommand({
      id: "disable-privacy-mode",
      name: "Disable privacy mode",
      callback: () => this.privacy.setEnabled(false)
    });
  }
  notifySettingsChanged() {
    this.privacy.onSettingsChanged();
  }
  notify(msg) {
    if (this.settings.showNotices) new import_obsidian3.Notice(msg);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy9wcml2YWN5L1ByaXZhY3lDb250cm9sbGVyLnRzIiwgInNyYy9wcml2YWN5L2NtNi9Qcml2YWN5RXh0ZW5zaW9uLnRzIiwgInNyYy9wcml2YWN5L2NtNi9tYXNraW5nL2J1aWxkTWFza0RlY29yYXRpb25zLnRzIiwgInNyYy9wcml2YWN5L2NtNi9tYXNraW5nL3Jhbmdlcy50cyIsICJzcmMvcHJpdmFjeS9jbTYvbWFza2luZy9oZWFkZXJzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBQbHVnaW4sIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgTXlQbHVnaW5TZXR0aW5ncywgU2FtcGxlU2V0dGluZ1RhYiB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBQcml2YWN5Q29udHJvbGxlciB9IGZyb20gXCIuL3ByaXZhY3kvUHJpdmFjeUNvbnRyb2xsZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5ncyE6IE15UGx1Z2luU2V0dGluZ3M7XG4gIHByaXZhdGUgcHJpdmFjeSE6IFByaXZhY3lDb250cm9sbGVyO1xuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG4gICAgdGhpcy5wcml2YWN5ID0gbmV3IFByaXZhY3lDb250cm9sbGVyKHRoaXMpO1xuXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgdGhpcy5yZWdpc3RlckNvbW1hbmRzKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHJ1bnRpbWUgZnJvbSBwZXJzaXN0ZWQgc2V0dGluZ3NcbiAgICB0aGlzLnByaXZhY3kuc3luY0Zyb21TZXR0aW5ncyh7IHJlYXNvbjogXCJzdGFydHVwXCIgfSk7XG4gIH1cblxuICBvbnVubG9hZCgpIHtcbiAgICB0aGlzLnByaXZhY3k/LmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJDb21tYW5kcygpIHtcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwidG9nZ2xlLXByaXZhY3ktbW9kZVwiLFxuICAgICAgbmFtZTogXCJUb2dnbGUgcHJpdmFjeSBtb2RlXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5wcml2YWN5LnRvZ2dsZUVuYWJsZWQoKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJlbmFibGUtcHJpdmFjeS1tb2RlXCIsXG4gICAgICBuYW1lOiBcIkVuYWJsZSBwcml2YWN5IG1vZGVcIixcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnByaXZhY3kuc2V0RW5hYmxlZCh0cnVlKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJkaXNhYmxlLXByaXZhY3ktbW9kZVwiLFxuICAgICAgbmFtZTogXCJEaXNhYmxlIHByaXZhY3kgbW9kZVwiLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucHJpdmFjeS5zZXRFbmFibGVkKGZhbHNlKSxcbiAgICB9KTtcbiAgfVxuXG4gIG5vdGlmeVNldHRpbmdzQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnByaXZhY3kub25TZXR0aW5nc0NoYW5nZWQoKTtcbiAgfVxuXG4gIG5vdGlmeShtc2c6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnNob3dOb3RpY2VzKSBuZXcgTm90aWNlKG1zZyk7XG4gIH1cblxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIChhd2FpdCB0aGlzLmxvYWREYXRhKCkpIGFzIFBhcnRpYWw8TXlQbHVnaW5TZXR0aW5ncz4pO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmV4cG9ydCB0eXBlIE1hc2tNb2RlID0gXCJoaWRlXCIgfCBcInBhc3N3b3JkXCIgfCBcImJsdXJcIjtcbmV4cG9ydCB0eXBlIFJldmVhbE1vZGUgPSBcIndvcmRcIiB8IFwibGV0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG5cdC8qKiBQZXJzaXN0ZWQgZ2xvYmFsIGRlZmF1bHQgc3RhdGUgKi9cblx0ZW5hYmxlZDogYm9vbGVhbjtcblxuXHQvKiogSG93IHRvIG1hc2sgbm9uLXJldmVhbGVkIHRleHQgKi9cblx0bWFza01vZGU6IE1hc2tNb2RlO1xuXG5cdC8qKiBXaGF0IHRvIHJldmVhbCBhdCB0aGUgY3Vyc29yICovXG5cdHJldmVhbE1vZGU6IFJldmVhbE1vZGU7XG5cblx0LyoqIEtlZXAgTWFya2Rvd24gaGVhZGVycyB2aXNpYmxlICgjLCAjIywgZXRjLikgKi9cblx0ZXhjbHVkZUhlYWRlcnM6IGJvb2xlYW47XG5cblx0LyoqIElmIGVuYWJsZWQsIHNlbGVjdGlvbiBiZWNvbWVzIHZpc2libGUgd2hpbGUgc2VsZWN0ZWQgKi9cblx0cmV2ZWFsU2VsZWN0aW9uOiBib29sZWFuO1xuXG5cdC8qKiBPcHRpb25hbDogc2hvdyBhIG5vdGljZSB3aGVuIHRvZ2dsaW5nIChoZWxwZnVsIGR1cmluZyBkZXYpICovXG5cdHNob3dOb3RpY2VzOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTXlQbHVnaW5TZXR0aW5ncyA9IHtcblx0ZW5hYmxlZDogZmFsc2UsXG5cdG1hc2tNb2RlOiBcImhpZGVcIixcblx0cmV2ZWFsTW9kZTogXCJ3b3JkXCIsXG5cdGV4Y2x1ZGVIZWFkZXJzOiB0cnVlLFxuXHRyZXZlYWxTZWxlY3Rpb246IHRydWUsXG5cdHNob3dOb3RpY2VzOiB0cnVlLFxufTtcblxuZXhwb3J0IGNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBNeVBsdWdpbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNeVBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiUHJpdmFjeSBNb2RlXCIgfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiUHJpdmFjeSBtb2RlIChnbG9iYWwpXCIpXG5cdFx0XHQuc2V0RGVzYyhcblx0XHRcdFx0XCJUdXJucyBtYXNraW5nIG9uL29mZi4gWW91IGNhbiBhbHNvIGJpbmQgYSBob3RrZXkgdG8gdGhlIFRvZ2dsZSBwcml2YWN5IG1vZGUgY29tbWFuZC5cIlxuXHRcdFx0KVxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuXHRcdFx0XHR0b2dnbGUuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlZCkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlZCA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vdGlmeVNldHRpbmdzQ2hhbmdlZCgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJNYXNrIHN0eWxlXCIpXG5cdFx0XHQuc2V0RGVzYyhcIkhpZGUgY2hhcmFjdGVycyBlbnRpcmVseSwgb3Igc2hvdyAqKioqKiBpbiBwbGFjZSBvZiBsZXR0ZXJzLlwiKVxuXHRcdFx0LmFkZERyb3Bkb3duKChkZCkgPT4ge1xuXHRcdFx0XHRkZC5hZGRPcHRpb24oXCJoaWRlXCIsIFwiSGlkZW4gKGJsYW5rKVwiKTtcblx0XHRcdFx0ZGQuYWRkT3B0aW9uKFwiYmx1clwiLCBcIkJsdXJyZWRcIik7XG5cdFx0XHRcdGRkLmFkZE9wdGlvbihcInBhc3N3b3JkXCIsIFwiUGFzc3dvcmQgKCoqKioqKSAobWF5IGhhdmUgZm9ybWF0dGluZyBpc3N1ZXMpXCIpO1xuXHRcdFx0XHRkZC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tYXNrTW9kZSk7XG5cdFx0XHRcdGRkLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLm1hc2tNb2RlID0gdmFsdWUgYXMgTWFza01vZGU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4ubm90aWZ5U2V0dGluZ3NDaGFuZ2VkKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiUmV2ZWFsIGF0IGN1cnNvclwiKVxuXHRcdFx0LnNldERlc2MoXCJXaGF0IHNob3VsZCByZW1haW4gdmlzaWJsZSBhdCB0aGUgY3Vyc29yIHBvc2l0aW9uLlwiKVxuXHRcdFx0LmFkZERyb3Bkb3duKChkZCkgPT4ge1xuXHRcdFx0XHRkZC5hZGRPcHRpb24oXCJ3b3JkXCIsIFwiQ3VycmVudCB3b3JkXCIpO1xuXHRcdFx0XHRkZC5hZGRPcHRpb24oXCJsZXR0ZXJcIiwgXCJDdXJyZW50IGxldHRlclwiKTtcblx0XHRcdFx0ZGQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmV2ZWFsTW9kZSk7XG5cdFx0XHRcdGRkLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJldmVhbE1vZGUgPSB2YWx1ZSBhcyBSZXZlYWxNb2RlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vdGlmeVNldHRpbmdzQ2hhbmdlZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIkV4Y2x1ZGUgaGVhZGVyc1wiKVxuXHRcdFx0LnNldERlc2MoXCJLZWVwIE1hcmtkb3duIGhlYWRlcnMgKCMsICMjLCAjIyMsIGV0Yy4pIHZpc2libGUuXCIpXG5cdFx0XHQuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG5cdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5leGNsdWRlSGVhZGVycykub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuZXhjbHVkZUhlYWRlcnMgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5ub3RpZnlTZXR0aW5nc0NoYW5nZWQoKTtcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKFwiUmV2ZWFsIHNlbGVjdGVkIHRleHRcIilcblx0XHRcdC5zZXREZXNjKFwiSWYgZW5hYmxlZCwgc2VsZWN0ZWQgdGV4dCBiZWNvbWVzIHZpc2libGUgd2hpbGUgc2VsZWN0ZWQuXCIpXG5cdFx0XHQuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG5cdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZXZlYWxTZWxlY3Rpb24pLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJldmVhbFNlbGVjdGlvbiA9IHZhbHVlO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vdGlmeVNldHRpbmdzQ2hhbmdlZCgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJTaG93IG5vdGljZXNcIilcblx0XHRcdC5zZXREZXNjKFwiU2hvdyBhIHBvcHVwIG5vdGljZSB3aGVuIHRvZ2dsaW5nICh1c2VmdWwgd2hpbGUgZGV2ZWxvcGluZykuXCIpXG5cdFx0XHQuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG5cdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG93Tm90aWNlcykub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd05vdGljZXMgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHQvLyBObyBuZWVkIHRvIHJlLWFwcGx5IG1hc2tpbmcganVzdCBiZWNhdXNlIG5vdGljZSBwcmVmZXJlbmNlIGNoYW5nZWQuXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IFwiSG90a2V5XCIgfSk7XG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJwXCIsIHtcblx0XHRcdHRleHQ6XG5cdFx0XHRcdFwiQmluZCBhIGhvdGtleSB0bzogU2V0dGluZ3MgXHUyMTkyIEhvdGtleXMgXHUyMTkyIHNlYXJjaCBcdTIwMUNUb2dnbGUgcHJpdmFjeSBtb2RlXHUyMDFELiBcIiArXG5cdFx0XHRcdFwiT2JzaWRpYW4ga2V5YmluZHMgY29tbWFuZHMgcmF0aGVyIHRoYW4gcGx1Z2lucyBoYXJkY29kaW5nIGtleSBjb21ib3MuXCIsXG5cdFx0fSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgdHlwZSBNeVBsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xyXG5pbXBvcnQgeyBNYXJrZG93blZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIjtcclxuaW1wb3J0IHsgQ29tcGFydG1lbnQsIHR5cGUgRXh0ZW5zaW9uIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XHJcbmltcG9ydCB0eXBlIHsgRWRpdG9yVmlldyB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XHJcbmltcG9ydCB7IGJ1aWxkUHJpdmFjeUV4dGVuc2lvbiB9IGZyb20gXCIuL2NtNi9Qcml2YWN5RXh0ZW5zaW9uXCI7XHJcblxyXG50eXBlIEFwcGx5UmVhc29uID0gXCJzdGFydHVwXCIgfCBcImNvbW1hbmRcIiB8IFwic2V0dGluZ3MtY2hhbmdlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJpdmFjeUNvbnRyb2xsZXIge1xyXG4gIHByaXZhdGUgcGx1Z2luOiBNeVBsdWdpbjtcclxuXHJcbiAgcHJpdmF0ZSBlbmFibGVkOiBib29sZWFuO1xyXG5cclxuICBwcml2YXRlIGNvbXBhcnRtZW50ID0gbmV3IENvbXBhcnRtZW50KCk7XHJcbiAgcHJpdmF0ZSBiYXNlRXh0ZW5zaW9uOiBFeHRlbnNpb247XHJcblxyXG4gIGNvbnN0cnVjdG9yKHBsdWdpbjogTXlQbHVnaW4pIHtcclxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG4gICAgdGhpcy5lbmFibGVkID0gcGx1Z2luLnNldHRpbmdzLmVuYWJsZWQ7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgT05FIGVkaXRvciBleHRlbnNpb24sIGFuZCByZWNvbmZpZ3VyZSBpdCB2aWEgYSBDb21wYXJ0bWVudC5cclxuICAgIHRoaXMuYmFzZUV4dGVuc2lvbiA9IHRoaXMuY29tcGFydG1lbnQub2YoXHJcbiAgICAgIGJ1aWxkUHJpdmFjeUV4dGVuc2lvbih7XHJcbiAgICAgICAgZW5hYmxlZDogdGhpcy5lbmFibGVkLFxyXG4gICAgICAgIHNldHRpbmdzOiB0aGlzLnBsdWdpbi5zZXR0aW5ncyxcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24odGhpcy5iYXNlRXh0ZW5zaW9uKTtcclxuXHJcbiAgICAvLyBSZS1hcHBseSB3aGVuIHN3aXRjaGluZyBwYW5lcy9ub3Rlc1xyXG4gICAgY29uc3Qgb2ZmMSA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2Uub24oXCJhY3RpdmUtbGVhZi1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5hcHBseShcInNldHRpbmdzLWNoYW5nZVwiKSk7XHJcbiAgICBjb25zdCBvZmYyID0gdGhpcy5wbHVnaW4uYXBwLndvcmtzcGFjZS5vbihcImxheW91dC1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5hcHBseShcInNldHRpbmdzLWNoYW5nZVwiKSk7XHJcbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlcigoKSA9PiB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLm9mZnJlZihvZmYxKSk7XHJcbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlcigoKSA9PiB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLm9mZnJlZihvZmYyKSk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCkge1xyXG4gICAgLy8gT2JzaWRpYW4gd2lsbCBjbGVhbiB1cCByZWdpc3RlcmVkIGVkaXRvciBleHRlbnNpb25zIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAvLyBJZiB5b3UgbGF0ZXIgYWRkIG1hbnVhbCBsaXN0ZW5lcnMgaW4gQ00gbGFuZCwgY2xlYW4gdGhlbSB0aGVyZS5cclxuICB9XHJcblxyXG4gIHN5bmNGcm9tU2V0dGluZ3Mob3B0czogeyByZWFzb246IEFwcGx5UmVhc29uIH0pIHtcclxuICAgIHRoaXMuZW5hYmxlZCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZWQ7XHJcbiAgICB0aGlzLmFwcGx5KG9wdHMucmVhc29uKTtcclxuICB9XHJcblxyXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XHJcbiAgICB0aGlzLnNldEVuYWJsZWQoIXRoaXMuZW5hYmxlZCk7XHJcbiAgfVxyXG5cclxuICBzZXRFbmFibGVkKG5leHQ6IGJvb2xlYW4pIHtcclxuICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IG5leHQpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLmVuYWJsZWQgPSBuZXh0O1xyXG4gICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlZCA9IG5leHQ7XHJcbiAgICB2b2lkIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cclxuICAgIHRoaXMucGx1Z2luLm5vdGlmeShgUHJpdmFjeSBtb2RlOiAke25leHQgPyBcIk9OXCIgOiBcIk9GRlwifWApO1xyXG4gICAgdGhpcy5hcHBseShcImNvbW1hbmRcIik7XHJcbiAgfVxyXG5cclxuICBvblNldHRpbmdzQ2hhbmdlZCgpIHtcclxuICAgIC8vIFNldHRpbmdzIHRhYiBzYXZlZCBzb21ldGhpbmcgXHUyMDE0IHB1c2ggdXBkYXRlZCBjb25maWdcclxuICAgIHRoaXMuYXBwbHkoXCJzZXR0aW5ncy1jaGFuZ2VcIik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFwcGx5KF9yZWFzb246IEFwcGx5UmVhc29uKSB7XHJcbiAgICAvLyBSZWNvbmZpZ3VyZSBldmVyeSBhY3RpdmUgQ002IGVkaXRvciB2aWV3XHJcbiAgICBjb25zdCBleHQgPSBidWlsZFByaXZhY3lFeHRlbnNpb24oe1xyXG4gICAgICBlbmFibGVkOiB0aGlzLmVuYWJsZWQsXHJcbiAgICAgIHNldHRpbmdzOiB0aGlzLnBsdWdpbi5zZXR0aW5ncyxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuY29tcGFydG1lbnQucmVjb25maWd1cmUoZXh0KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHZpZXcgb2YgdGhpcy5nZXRBbGxNYXJrZG93bkVkaXRvclZpZXdzKCkpIHtcclxuICAgICAgY29uc3QgY20gPSB0aGlzLmdldEVkaXRvclZpZXcodmlldyk7XHJcbiAgICAgIGlmICghY20pIGNvbnRpbnVlO1xyXG4gICAgICBjbS5kaXNwYXRjaCh7IGVmZmVjdHM6IGVmZmVjdCB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgKmdldEFsbE1hcmtkb3duRWRpdG9yVmlld3MoKTogSXRlcmFibGU8TWFya2Rvd25WaWV3PiB7XHJcbiAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShcIm1hcmtkb3duXCIpO1xyXG4gICAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xyXG4gICAgICBjb25zdCB2aWV3ID0gbGVhZi52aWV3O1xyXG4gICAgICBpZiAodmlldyBpbnN0YW5jZW9mIE1hcmtkb3duVmlldykgeWllbGQgdmlldztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic2lkaWFuJ3MgRWRpdG9yIGlzIHdyYXBwZWQ7IGluIENNNiBpdCB1c3VhbGx5IGV4cG9zZXMgYC5jbWAgYXMgRWRpdG9yVmlldy5cclxuICAgKiBUaGlzIGlzIHRoZSBjb21tb24gcGx1Z2luIHBhdHRlcm4uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRFZGl0b3JWaWV3KHZpZXc6IE1hcmtkb3duVmlldyk6IEVkaXRvclZpZXcgfCBudWxsIHtcclxuICAgIGNvbnN0IGVkaXRvckFueSA9IHZpZXcuZWRpdG9yIGFzIGFueTtcclxuICAgIGNvbnN0IGNtID0gZWRpdG9yQW55Py5jbTtcclxuICAgIHJldHVybiBjbSA/PyBudWxsO1xyXG4gIH1cclxufVxyXG4iLCAiaW1wb3J0IHR5cGUgeyBFeHRlbnNpb24gfSBmcm9tIFwiQGNvZGVtaXJyb3Ivc3RhdGVcIjtcclxuaW1wb3J0IHsgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgRGVjb3JhdGlvbiwgdHlwZSBEZWNvcmF0aW9uU2V0LCB0eXBlIFZpZXdVcGRhdGUgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xyXG5pbXBvcnQgdHlwZSB7IE15UGx1Z2luU2V0dGluZ3MgfSBmcm9tIFwiLi4vLi4vc2V0dGluZ3NcIjtcclxuaW1wb3J0IHsgYnVpbGRNYXNrRGVjb3JhdGlvbnMgfSBmcm9tIFwiLi9tYXNraW5nL2J1aWxkTWFza0RlY29yYXRpb25zXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcml2YWN5RXh0ZW5zaW9uKGFyZ3M6IHsgZW5hYmxlZDogYm9vbGVhbjsgc2V0dGluZ3M6IE15UGx1Z2luU2V0dGluZ3MgfSk6IEV4dGVuc2lvbiB7XHJcbiAgY29uc3QgeyBlbmFibGVkLCBzZXR0aW5ncyB9ID0gYXJncztcclxuXHJcbiAgY29uc3QgZWRpdG9yQXR0cnMgPSBFZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMub2Yoe1xyXG4gICAgY2xhc3M6IGVuYWJsZWQgPyBcInByaXZhY3ktbW9kZS1lbmFibGVkXCIgOiBcIlwiLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhcclxuICAgIGNsYXNzIFByaXZhY3lNYXNrUGx1Z2luIHtcclxuICAgICAgZGVjb3JhdGlvbnM6IERlY29yYXRpb25TZXQ7XHJcblxyXG4gICAgICBjb25zdHJ1Y3Rvcih2aWV3OiBFZGl0b3JWaWV3KSB7XHJcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkTWFza0RlY29yYXRpb25zKHZpZXcsIGVuYWJsZWQsIHNldHRpbmdzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xyXG4gICAgICAgIGlmICghZW5hYmxlZCkge1xyXG4gICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkTWFza0RlY29yYXRpb25zKHVwZGF0ZS52aWV3LCBlbmFibGVkLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgeyBkZWNvcmF0aW9uczogKHYpID0+IHYuZGVjb3JhdGlvbnMgfVxyXG4gICk7XHJcblxyXG4gIHJldHVybiBbZWRpdG9yQXR0cnMsIHBsdWdpbl07XHJcbn1cclxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yVmlldyB9IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XHJcbmltcG9ydCB7IERlY29yYXRpb24gfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xyXG5pbXBvcnQgdHlwZSB7IE15UGx1Z2luU2V0dGluZ3MgfSBmcm9tIFwiLi4vLi4vLi4vc2V0dGluZ3NcIjtcclxuaW1wb3J0IHsgY29tcHV0ZVJldmVhbFJhbmdlcywgc3VidHJhY3RSYW5nZXMsIG1lcmdlUmFuZ2VzLCB0eXBlIFJhbmdlIH0gZnJvbSBcIi4vcmFuZ2VzXCI7XHJcbmltcG9ydCB7IGlzSGVhZGVyTGluZSB9IGZyb20gXCIuL2hlYWRlcnNcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1hc2tEZWNvcmF0aW9ucyh2aWV3OiBFZGl0b3JWaWV3LCBlbmFibGVkOiBib29sZWFuLCBzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncykge1xyXG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuXHJcbiAgY29uc3QgYnVpbGRlciA9IG5ldyAoY2xhc3Mge1xyXG4gICAgZGVjb3M6IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyOyBkZWNvOiBhbnkgfVtdID0gW107XHJcbiAgICBhZGQoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBkZWNvOiBhbnkpIHtcclxuICAgICAgdGhpcy5kZWNvcy5wdXNoKHsgZnJvbSwgdG8sIGRlY28gfSk7XHJcbiAgICB9XHJcbiAgICBmaW5pc2goKSB7XHJcbiAgICAgIC8vIEBjb2RlbWlycm9yL3ZpZXcgZXhwZWN0cyBSYW5nZTxEZWNvcmF0aW9uPjsgT2JzaWRpYW4gYnVuZGxlcyBSYW5nZVNldEJ1aWxkZXIsXHJcbiAgICAgIC8vIGJ1dCBhIHNpbXBsZSBidWlsZCB3b3JrcyB2aWEgRGVjb3JhdGlvbi5zZXQoWy4uLl0pIHRvby5cclxuICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHRoaXMuZGVjb3MubWFwKChkKSA9PiBkLmRlY28ucmFuZ2UoZC5mcm9tLCBkLnRvKSksIHRydWUpO1xyXG4gICAgfVxyXG4gIH0pKCk7XHJcblxyXG4gIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcclxuXHJcbiAgLy8gMSkgQ29tcHV0ZSByZXZlYWwgcmFuZ2VzIChjdXJzb3IgbGV0dGVyL3dvcmQvbm9uZSlcclxuICBjb25zdCBjdXJzb3JSZXZlYWwgPSBjb21wdXRlUmV2ZWFsUmFuZ2VzKHN0YXRlLCBzZXR0aW5ncy5yZXZlYWxNb2RlKTtcclxuXHJcbiAgLy8gMikgQ29tcHV0ZSBzZWxlY3Rpb24gcmV2ZWFsIHJhbmdlcyAoaWYgZW5hYmxlZClcclxuICBjb25zdCBzZWxlY3Rpb25SZXZlYWw6IFJhbmdlW10gPSBzZXR0aW5ncy5yZXZlYWxTZWxlY3Rpb25cclxuICAgID8gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1xyXG4gICAgICAgIC5maWx0ZXIoKHIpID0+ICFyLmVtcHR5KVxyXG4gICAgICAgIC5tYXAoKHIpID0+ICh7IGZyb206IE1hdGgubWluKHIuZnJvbSwgci50byksIHRvOiBNYXRoLm1heChyLmZyb20sIHIudG8pIH0pKVxyXG4gICAgOiBbXTtcclxuXHJcblxyXG4gIGNvbnN0IHJldmVhbFJhbmdlcyA9IG1lcmdlUmFuZ2VzKFsuLi5jdXJzb3JSZXZlYWwsIC4uLnNlbGVjdGlvblJldmVhbF0pO1xyXG5cclxuICAvLyAzKSBCdWlsZCBtYXNraW5nIHBlciB2aXNpYmxlIGxpbmVcclxuICBmb3IgKGNvbnN0IHZyIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xyXG4gICAgbGV0IHBvcyA9IHZyLmZyb207XHJcblxyXG4gICAgd2hpbGUgKHBvcyA8PSB2ci50bykge1xyXG4gICAgICBjb25zdCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xyXG5cclxuICAgICAgLy8gc3RvcCBpZiB3ZSd2ZSBtb3ZlZCBwYXN0IHZpZXdwb3J0XHJcbiAgICAgIGlmIChsaW5lLmZyb20gPiB2ci50bykgYnJlYWs7XHJcblxyXG4gICAgICBjb25zdCBleGNsdWRlVGhpc0xpbmUgPSBzZXR0aW5ncy5leGNsdWRlSGVhZGVycyAmJiBpc0hlYWRlckxpbmUobGluZS50ZXh0KTtcclxuXHJcbiAgICAgIGlmICghZXhjbHVkZVRoaXNMaW5lKSB7XHJcbiAgICAgICAgLy8gTWFzayB0aGUgd2hvbGUgbGluZSB0ZXh0IChub3QgaW5jbHVkaW5nIG5ld2xpbmUpXHJcbiAgICAgICAgY29uc3QgbGluZVJhbmdlOiBSYW5nZSA9IHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS50byB9O1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCByZXZlYWwgcmFuZ2VzIHRoYXQgb3ZlcmxhcCB0aGlzIGxpbmVcclxuICAgICAgICBjb25zdCByZXZlYWxJbkxpbmUgPSByZXZlYWxSYW5nZXNcclxuICAgICAgICAgIC5maWx0ZXIoKHIpID0+IHIudG8gPiBsaW5lUmFuZ2UuZnJvbSAmJiByLmZyb20gPCBsaW5lUmFuZ2UudG8pXHJcbiAgICAgICAgICAubWFwKChyKSA9PiAoe1xyXG4gICAgICAgICAgICBmcm9tOiBNYXRoLm1heChyLmZyb20sIGxpbmVSYW5nZS5mcm9tKSxcclxuICAgICAgICAgICAgdG86IE1hdGgubWluKHIudG8sIGxpbmVSYW5nZS50byksXHJcbiAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hc2tTZWdtZW50cyA9IHN1YnRyYWN0UmFuZ2VzKFtsaW5lUmFuZ2VdLCByZXZlYWxJbkxpbmUpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHNlZyBvZiBtYXNrU2VnbWVudHMpIHtcclxuICAgICAgICAgIGlmIChzZWcudG8gPD0gc2VnLmZyb20pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHNlZy50byAtIHNlZy5mcm9tO1xyXG4gICAgICAgICAgY29uc3QgY2xzID1cclxuICAgICAgICAgICAgICBzZXR0aW5ncy5tYXNrTW9kZSA9PT0gXCJoaWRlXCIgPyBcInByaXZhY3ktbWFzay1oaWRlXCIgOlxyXG4gICAgICAgICAgICBzZXR0aW5ncy5tYXNrTW9kZSA9PT0gXCJwYXNzd29yZFwiID8gXCJwcml2YWN5LW1hc2stcGFzc3dvcmRcIiA6XHJcbiAgICAgICAgICAgIFwicHJpdmFjeS1tYXNrLWJsdXJcIjtcclxuXHJcbiAgICAgICAgICBidWlsZGVyLmFkZChzZWcuZnJvbSwgc2VnLnRvLCBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogY2xzIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkdmFuY2UgdG8gbmV4dCBsaW5lXHJcbiAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xyXG4gICAgICBpZiAocG9zID09PSBsaW5lLmZyb20pIGJyZWFrOyAvLyBzYWZldHlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xyXG59XHJcbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XHJcblxyXG5leHBvcnQgdHlwZSBSYW5nZSA9IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VSYW5nZXMocmFuZ2VzOiBSYW5nZVtdKTogUmFuZ2VbXSB7XHJcbiAgY29uc3Qgc29ydGVkID0gcmFuZ2VzXHJcbiAgICAuZmlsdGVyKChyKSA9PiByLnRvID4gci5mcm9tKVxyXG4gICAgLnNsaWNlKClcclxuICAgIC5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG8pO1xyXG5cclxuICBjb25zdCBtZXJnZWQ6IFJhbmdlW10gPSBbXTtcclxuICBmb3IgKGNvbnN0IHIgb2Ygc29ydGVkKSB7XHJcbiAgICBjb25zdCBsYXN0ID0gbWVyZ2VkW21lcmdlZC5sZW5ndGggLSAxXTtcclxuICAgIGlmICghbGFzdCB8fCByLmZyb20gPiBsYXN0LnRvKSBtZXJnZWQucHVzaCh7IC4uLnIgfSk7XHJcbiAgICBlbHNlIGxhc3QudG8gPSBNYXRoLm1heChsYXN0LnRvLCByLnRvKTtcclxuICB9XHJcbiAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0UmFuZ2VzKGJhc2U6IFJhbmdlW10sIHN1YnRyYWN0OiBSYW5nZVtdKTogUmFuZ2VbXSB7XHJcbiAgY29uc3QgYiA9IG1lcmdlUmFuZ2VzKGJhc2UpO1xyXG4gIGNvbnN0IHMgPSBtZXJnZVJhbmdlcyhzdWJ0cmFjdCk7XHJcblxyXG4gIGNvbnN0IG91dDogUmFuZ2VbXSA9IFtdO1xyXG4gIGZvciAoY29uc3QgYnIgb2YgYikge1xyXG4gICAgbGV0IGN1cnNvciA9IGJyLmZyb207XHJcblxyXG4gICAgZm9yIChjb25zdCBzciBvZiBzKSB7XHJcbiAgICAgIGlmIChzci50byA8PSBjdXJzb3IpIGNvbnRpbnVlO1xyXG4gICAgICBpZiAoc3IuZnJvbSA+PSBici50bykgYnJlYWs7XHJcblxyXG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KGN1cnNvciwgYnIuZnJvbSk7XHJcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHNyLmZyb20sIGJyLnRvKTtcclxuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSBvdXQucHVzaCh7IGZyb206IHN0YXJ0LCB0bzogZW5kIH0pO1xyXG5cclxuICAgICAgY3Vyc29yID0gTWF0aC5tYXgoY3Vyc29yLCBzci50byk7XHJcbiAgICAgIGlmIChjdXJzb3IgPj0gYnIudG8pIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJzb3IgPCBici50bykgb3V0LnB1c2goeyBmcm9tOiBjdXJzb3IsIHRvOiBici50byB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvdXQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUmV2ZWFsUmFuZ2VzKFxyXG4gIHN0YXRlOiBFZGl0b3JTdGF0ZSxcclxuICByZXZlYWxNb2RlOiBcIndvcmRcIiB8IFwibGV0dGVyXCJcclxuKTogUmFuZ2VbXSB7XHJcbiAgLy8gVXNlIHByaW1hcnkgY3Vyc29yIChoZWFkKSBmb3Igbm93OyBsYXRlciB5b3UgY2FuIHN1cHBvcnQgbXVsdGktY3Vyc29yLlxyXG4gIGNvbnN0IHBvcyA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XHJcblxyXG4gIGlmIChyZXZlYWxNb2RlID09PSBcImxldHRlclwiKSB7XHJcbiAgICAvLyBSZXZlYWwgY2hhcmFjdGVyIFwidW5kZXJcIiBjdXJzb3IgaWYgcG9zc2libGUsIGVsc2UgcHJldmlvdXNcclxuICAgIGlmIChwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoKSByZXR1cm4gW3sgZnJvbTogcG9zLCB0bzogcG9zICsgMSB9XTtcclxuICAgIGlmIChwb3MgPiAwKSByZXR1cm4gW3sgZnJvbTogcG9zIC0gMSwgdG86IHBvcyB9XTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIC8vIHJldmVhbE1vZGUgPT09IFwid29yZFwiXHJcbiAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcclxuICBjb25zdCBpZHggPSBwb3MgLSBsaW5lLmZyb207XHJcblxyXG4gIGNvbnN0IGlzV29yZENoYXIgPSAoY2g6IHN0cmluZykgPT4gL1tBLVphLXowLTlfXS8udGVzdChjaCk7XHJcblxyXG4gIGxldCBsZWZ0ID0gaWR4O1xyXG4gIHdoaWxlIChsZWZ0ID4gMCAmJiBpc1dvcmRDaGFyKGxpbmUudGV4dC5jaGFyQXQobGVmdCAtIDEpKSkgbGVmdC0tO1xyXG5cclxuICBsZXQgcmlnaHQgPSBpZHg7XHJcbiAgd2hpbGUgKHJpZ2h0IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpc1dvcmRDaGFyKGxpbmUudGV4dC5jaGFyQXQocmlnaHQpKSkgcmlnaHQrKztcclxuXHJcbiAgaWYgKHJpZ2h0IDw9IGxlZnQpIHtcclxuICAgIC8vIE5vIHdvcmQgY2hhciBhdCBjdXJzb3IgXHUyMDE0IHJldmVhbCBub3RoaW5nXHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICByZXR1cm4gW3sgZnJvbTogbGluZS5mcm9tICsgbGVmdCwgdG86IGxpbmUuZnJvbSArIHJpZ2h0IH1dO1xyXG59XHJcbiIsICJleHBvcnQgZnVuY3Rpb24gaXNIZWFkZXJMaW5lKGxpbmVUZXh0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAvLyBNYXJrZG93biBoZWFkZXI6IHVwIHRvIDMgbGVhZGluZyBzcGFjZXMsIDEtNiAjJ3MsIHRoZW4gYSBzcGFjZVxyXG4gIHJldHVybiAvXlxcc3swLDN9I3sxLDZ9XFxzLy50ZXN0KGxpbmVUZXh0KTtcclxufVxyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQStCOzs7QUNBL0Isc0JBQStDO0FBMEJ4QyxJQUFNLG1CQUFxQztBQUFBLEVBQ2pELFNBQVM7QUFBQSxFQUNULFVBQVU7QUFBQSxFQUNWLFlBQVk7QUFBQSxFQUNaLGdCQUFnQjtBQUFBLEVBQ2hCLGlCQUFpQjtBQUFBLEVBQ2pCLGFBQWE7QUFDZDtBQUVPLElBQU0sbUJBQU4sY0FBK0IsaUNBQWlCO0FBQUEsRUFHdEQs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LGlCQUFpQjtBQUd0QixTQUFLLFFBQVEsaUJBQWlCLEVBQUUsUUFBUSxVQUFVLENBQUM7QUFBQSxFQUNyRDtBQUFBLEVBRUEsV0FBVztBQXBCYjtBQXFCSSxlQUFLLFlBQUwsbUJBQWM7QUFBQSxFQUNoQjtBQUFBLEVBRVEsbUJBQW1CO0FBQ3pCLFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssUUFBUSxjQUFjO0FBQUEsSUFDN0MsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssUUFBUSxXQUFXLElBQUk7QUFBQSxJQUM5QyxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLE1BQU0sS0FBSyxRQUFRLFdBQVcsS0FBSztBQUFBLElBQy9DLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFQSx3QkFBd0I7QUFDdEIsU0FBSyxRQUFRLGtCQUFrQjtBQUFBLEVBQ2pDO0FBQUEsRUFFQSxPQUFPLEtBQWE7QUFDbEIsUUFBSSxLQUFLLFNBQVMsWUFBYSxLQUFJLHdCQUFPLEdBQUc7QUFBQSxFQUMvQztBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ25CLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFtQixNQUFNLEtBQUssU0FBUyxDQUErQjtBQUFBLEVBQzFHO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbkM7QUFDRjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmlldyJdCn0K
